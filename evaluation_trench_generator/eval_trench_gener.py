# -*- coding: utf-8 -*-
"""
/***************************************************************************
 EvalTrenchGenerator
                                 A QGIS plugin
 This plugin generates evaluation trenches for archaeological evaluations.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-07-07
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Valerio Pinna
        email                : pinnavalerio@yahoo.co.uk
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, QVariant
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction,QMessageBox, QToolBar
from qgis.core import *
from qgis.utils import iface
from PyQt5 import QtGui
import processing
import inspect
import glob
import os
import csv

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .eval_trench_gener_dialog import EvalTrenchGeneratorDialog
from .eval_trench_route_numbers_dialog import EvalTrenchRouteNumbersDialog
from .eval_trench_stakeout_points_dialog import EvalTrenchGenerateStakeOutPointsDialog
from .eval_trench_stakeout_route_CSV_dialog import EvalTrenchStakeOutRouteCSVDialog

import os.path

cmd_folder = os.path.split(inspect.getfile(inspect.currentframe()))[0]


class EvalTrenchGenerator:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'EvalTrenchGenerator_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        self.dlg2 = EvalTrenchRouteNumbersDialog()

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Evaluation Trench Generator')

        self.toolbar = iface.mainWindow().findChild( QToolBar, u'Evaluation Trench Generator' )
        if not self.toolbar:
            self.toolbar = iface.addToolBar( u'Evaluation Trench Generator' )
            self.toolbar.setObjectName( u'Evaluation Trench Generator' )
            self.toolbar.setToolTip("")
        
        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('EvalTrenchGenerator', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        self.OAElogo= self.add_action( 
            icon_path = ':/plugins/eval_trench_gener/icons/trench_generator_icon.png',
            text=self.tr(u'Generate the evaluation trenches'),
            callback=self.generate_trenches,
            parent=self.iface.mainWindow())
        # will be set False in generate_trenches()
        self.first_start = True

        self.layergeneratoricon= self.add_action( 
            icon_path = ':/plugins/eval_trench_gener/icons/trench_counterclock_rotation_icon.png',
            text=self.tr(u'Rotate the trench counterclockwise'),
            callback=self.rotateTrench_counterclockwise,
            parent=self.iface.mainWindow())
        # will be set False in run()
        self.first_start = True
        
        self.layergeneratoricon= self.add_action( 
            icon_path = ':/plugins/eval_trench_gener/icons/trench_clock_rotation_icon.png',
            text=self.tr(u'Rotate the trench clockwise'),
            callback=self.rotateTrench_clockwise,
            parent=self.iface.mainWindow())
        # will be set False in run()
        self.first_start = True

        self.layergeneratoricon= self.add_action( 
            icon_path = ':/plugins/eval_trench_gener/icons/trench_route_numbers_icon.png',
            text=self.tr(u'Update the trench numeration according to a path'),
            callback=self.routeNumeration,
            parent=self.iface.mainWindow())
        # will be set False in run()
        self.first_start = True

        self.layergeneratoricon= self.add_action( 
            icon_path = ':/plugins/eval_trench_gener/icons/trench_points_icon.png',
            text=self.tr(u'Generate stake out points'),
            callback=self.generate_stakeout_points,
            parent=self.iface.mainWindow())
        # will be set False in run()
        self.first_start = True

        self.layergeneratoricon= self.add_action( 
            icon_path = ':/plugins/eval_trench_gener/icons/trench_CSV_icon.png',
            text=self.tr(u'Generate CSV file for stake out'),
            callback=self.generateCSV,
            parent=self.iface.mainWindow())
        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Evaluation Trench Generator'),
                action)
            self.iface.removeToolBarIcon(action)
    

    def get_sb_layer(self):
        layers_list = QgsProject.instance().mapLayers()
        
        if len(layers_list)!= 0:                  
            polygons_list = []            
            for lay in layers_list.values():
                if lay.type() == QgsVectorLayer.VectorLayer:
                    if lay.geometryType() == 2: #polygon
                        polygons_list.append(lay.name())
    
            self.dlg.sb_comboBox.clear()
            self.dlg.sb_comboBox.addItems(polygons_list)
        if len(layers_list)== 0:
            iface.messageBar().pushMessage(
                "Evaluation Trench Generator", 
                "No layers available. Please add a valid site boundary layer and retry.",
                level=Qgis.Warning, duration=0)  
            return self.dontdonothing()
            
    def get_route_layer(self):
        layers_list = QgsProject.instance().mapLayers()
        
        if len(layers_list)!= 0:                  
            lines_list = []            
            for lay in layers_list.values():
                if lay.type() == QgsVectorLayer.VectorLayer:
                    if lay.geometryType() == 1: #line
                        lines_list.append(lay.name())

            self.dlg2.routelayer_comboBox.clear()
            self.dlg2.routelayer_comboBox.addItems(lines_list) 
        if len(layers_list)== 0:
            iface.messageBar().pushMessage(
                "Evaluation Trench Generator", 
                "No route layers available. Please add a valid linear route layer and retry.",
                level=Qgis.Warning, duration=0)
            return self.dontdonothing()    
            
    def get_loe_layer(self):
        layers_list = QgsProject.instance().mapLayers()
        
        if len(layers_list)!= 0:                  
            loe_list = []            
            for lay in layers_list.values():
                if lay.type() == QgsVectorLayer.VectorLayer:
                    if lay.geometryType() == 2: #polygon
                        loe_list.append(lay.name())

            self.dlg2.trenchLOE_layer_comboBox.clear()
            self.dlg2.trenchLOE_layer_comboBox.addItems(loe_list)
        if len(layers_list)== 0:
            iface.messageBar().pushMessage(
                "Evaluation Trench Generator", 
                "No layers available. Please add a valid trenches limit of excavation layer and retry.",
                level=Qgis.Warning, duration=0)
            return self.dontdonothing()

    def check_trench_calc_type_number(self): 
        self.dlg.tr_num_spinBox.setEnabled(True)
        self.dlg.tr_no_label.setEnabled(True)
        
        self.dlg.sb_layer_label.setEnabled(True)
        self.dlg.sb_comboBox.setEnabled(True)
        self.dlg.button_box.setEnabled(True)
        
        self.dlg.tr_area_perc_spinBox_2.setEnabled(False)
        self.dlg.tr_area_label.setEnabled(False)
        
    def check_trench_calc_type_area(self): 
        self.dlg.tr_num_spinBox.setEnabled(False)
        self.dlg.tr_no_label.setEnabled(False)
        
        self.dlg.sb_layer_label.setEnabled(True)
        self.dlg.sb_comboBox.setEnabled(True)
        self.dlg.button_box.setEnabled(True)
        
        self.dlg.tr_area_perc_spinBox_2.setEnabled(True)
        self.dlg.tr_area_label.setEnabled(True)

    def generate_trenches(self):
        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            #self.first_start = False
            self.dlg = EvalTrenchGeneratorDialog()
            self.layers = {layer.name():layer for layer in QgsProject.instance().mapLayers().values() if layer.type()== 0}
            self.get_sb_layer()
        self.dlg.trench_by_number_checkBox.stateChanged.connect(self.check_trench_calc_type_number)
        self.dlg.trench_by_area_checkBox.stateChanged.connect(self.check_trench_calc_type_area)
        
        
        self.dlg.tr_num_spinBox.setEnabled(False)
        self.dlg.tr_area_perc_spinBox_2.setEnabled(False)
        self.dlg.tr_no_label.setEnabled(False)
        self.dlg.tr_area_label.setEnabled(False)
        self.dlg.sb_layer_label.setEnabled(False)
        self.dlg.sb_comboBox.setEnabled(False)
        
        self.dlg.button_box.setEnabled(False)
        
        self.dlg.add_empty_layer_pushButton.clicked.connect(self.add_empty_LOE_layer)
        
        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            trench_length = self.dlg.tr_l_doubleSpinBox.value()
            trench_width = self.dlg.tr_w_doubleSpinBox.value()
            trench_by_number = self.dlg.tr_num_spinBox.value()      
            area_to_cover_percentage = self.dlg.tr_area_perc_spinBox_2.value()
            trench_by_number_check = self.dlg.trench_by_number_checkBox.isChecked()
            trench_by_ares_check = self.dlg.trench_by_area_checkBox.isChecked()         
            site_boundary = self.dlg.sb_comboBox.currentText()
            
            #Check if the project is saved in the disk 
            # Get the file path of the current project
            project_file_path = QgsProject.instance().fileName()

            if project_file_path:
                print("The project has been saved to:", project_file_path)
            
            
                #project_dir = QgsProject.instance().homePath() + '/Shapefiles/Trench_LOE.shp'
                shapefile_dir = QgsProject.instance().homePath() + '/Shapefiles/'
                if not os.path.exists(shapefile_dir):
                    os.mkdir(shapefile_dir)
                
                #Check how many trench_loe files are already present in the folder
                trench_LOE_files_list = []
                os.chdir(shapefile_dir)
                for file in glob.glob("Trench_LOE*.shp"):
                    trench_LOE_files_list.append(file)

                if len(trench_LOE_files_list) == 0:
                    tr_LOE_filename = 'Trench_LOE.shp'

                if len(trench_LOE_files_list) > 0:
                    tr_LOE_filename = 'Trench_LOE_{}.shp'.format(len(trench_LOE_files_list))

                if tr_LOE_filename in trench_LOE_files_list:
                    tr_LOE_filename = 'Trench_LOE_{}.shp'.format((len(trench_LOE_files_list))+1)
                
                trench_LOE_path = shapefile_dir+tr_LOE_filename
            
            else:
                print("The project has not been saved yet.")
                #Define a name for the temporary Trench LOE layer
                tr_LOE_filename = 'Trench_LOE_temp.shp'
            
            
            if len(site_boundary) == 0:
                QMessageBox.about(None,'Evaluation Trench Generator', 'No site boundary layer was selected. Please select a layer.')
                return self.dontdonothing()
            
            else:
                self.shpLayer = self.layers[self.dlg.sb_comboBox.currentText()]

            trench_area = trench_length *trench_width
            
            if trench_by_number_check == True and trench_by_ares_check == True: 
                        QMessageBox.about(None,'Evaluation Trench Generator', 'Both options to define the number of trenches are selected. Please select only one option.')
                        return self.dontdonothing()
            if trench_by_number_check == False and trench_by_ares_check == False: 
                QMessageBox.about(None,'Evaluation Trench Generator', 'One option to define the number of trenches needs to be selected.') 
                return self.dontdonothing()
            
            layers = QgsProject.instance().mapLayers()
            if len(layers) == 0: 
                iface.messageBar().pushMessage(
                "Evaluation Trench Generator", 
                "No layers available. Please add a valid site boundary layer and retry.",
                level=Qgis.Warning, duration=0)
            if len(layers)!= 0:                  
                sbl = QgsProject.instance().mapLayersByName(site_boundary)[0]
                if sbl.geometryType() == 2: #polygon
                    
                    numb_of_feat_list = []
                    for feat in sbl.getFeatures():
                        numb_of_feat_list.append(feat)
                        
                    if len(numb_of_feat_list) == 0:
                        QMessageBox.about(None,'Evaluation Trench Generator', 'The selected layer is a empty layer. Draw a valid site boundary and retry.') 
                        return self.dontdonothing()
                    
                    if len(numb_of_feat_list) != 0:

                        #create a new temp layer
                        temp_layer = QgsVectorLayer("polygon?crs=epsg:27700", tr_LOE_filename, "memory")
                        pr = temp_layer.dataProvider()
                        pr.addAttributes([QgsField("id",  QVariant.Int),
                                          QgsField("loe_no", QVariant.Int),
                                          QgsField("surv_type", QVariant.String),
                                          QgsField("surv_notes", QVariant.String)])
                        temp_layer.updateFields() 
                        
                        
                        site_boundary_area_total = 0
                        for feature in sbl.getFeatures():
                            site_boundary_area_total += feature.geometry().area()

                        area_to_cover = (site_boundary_area_total*area_to_cover_percentage)/100
                        trench_number_by_area = area_to_cover/trench_area
                        
                        #calculate a -10m buffer on the site boundary
                        buffered_sbl = processing.run("native:buffer", {'INPUT':
                        sbl,'DISTANCE':-10,
                        'SEGMENTS':5,
                        'END_CAP_STYLE':0,
                        'JOIN_STYLE':0,
                        'MITER_LIMIT':2,
                        'DISSOLVE':False
                        ,'OUTPUT':'TEMPORARY_OUTPUT'}) ["OUTPUT"]
                                        

                        #create random points
                        random = processing.run("qgis:randompointsinsidepolygons", {'INPUT':buffered_sbl,
                        'STRATEGY':0,
                        'VALUE':10000,
                        'MIN_DISTANCE':None,
                        'OUTPUT':'TEMPORARY_OUTPUT'}) ["OUTPUT"]

                        #reate clusters
                        if trench_by_number_check == True and trench_by_ares_check == False: 
                            cluster = processing.run("native:kmeansclustering", {'INPUT':random,
                            'CLUSTERS':trench_by_number, ### here the number of trenches
                            'FIELD_NAME':'CLUSTER_ID',
                            'SIZE_FIELD_NAME':'CLUSTER_SIZE',
                            'OUTPUT':'TEMPORARY_OUTPUT'}) ["OUTPUT"]
                        
                        if trench_by_number_check == False and trench_by_ares_check == True: 
                            cluster = processing.run("native:kmeansclustering", {'INPUT':random,
                            'CLUSTERS':trench_number_by_area, ### here the number of trenches
                            'FIELD_NAME':'CLUSTER_ID',
                            'SIZE_FIELD_NAME':'CLUSTER_SIZE',
                            'OUTPUT':'TEMPORARY_OUTPUT'}) ["OUTPUT"]  
                            
                        if trench_by_number_check == True and trench_by_ares_check == True: 
                            QMessageBox.about(None,'Evaluation Trench Generator', 'Both options to define the number of trenches are selected. Select only on option.')

                        if trench_by_number_check == False and trench_by_ares_check == False: 
                            QMessageBox.about(None,'Evaluation Trench Generator', 'An option to define the number of trenches needs to be selected.') 
                            
                        #aggreagate
                        aggregated = processing.run("native:aggregate", {'INPUT':cluster,
                        'GROUP_BY':'"CLUSTER_ID"',
                        'AGGREGATES':[{'aggregate': 'sum','delimiter': ',','input': '"id"','length': 10,'name': 'id','precision': 0,'type': 2},{'aggregate': 'sum','delimiter': ',','input': '"CLUSTER_ID"','length': 0,'name': 'CLUSTER_ID','precision': 0,'type': 2},{'aggregate': 'sum','delimiter': ',','input': '"CLUSTER_SIZE"','length': 0,'name': 'CLUSTER_SIZE','precision': 0,'type': 2}],
                        'OUTPUT':'TEMPORARY_OUTPUT'}) ["OUTPUT"]

                        #centroids
                        centroids = processing.runAndLoadResults("native:centroids", {'INPUT':aggregated,
                        'ALL_PARTS':False,
                        'OUTPUT':'TEMPORARY_OUTPUT'}) 

                        new_points_temp_layer = QgsProject.instance().mapLayersByName('Centroids')[0]
                        for p in new_points_temp_layer.getFeatures():
                            x_point = p.geometry().asPoint().x()
                            y_point = p.geometry().asPoint().y()

                            corner1 = x_point+trench_width/2, y_point+trench_length/2
                            corner2 = x_point+trench_width/2, y_point-trench_length/2
                            corner3 = x_point-trench_width/2, y_point-trench_length/2
                            corner4 = x_point-trench_width/2, y_point+trench_length/2
                            
                            poly_coord = [corner1, corner2, corner3, corner4]

                            #add feature to layer
                            f = QgsFeature()
                            f.setAttributes([0, 0, 'trench'])
                            f.setGeometry(QgsGeometry.fromPolygonXY( [[ QgsPointXY( pair[0], pair[1] ) for pair in poly_coord ]] )) 
                            
                            pr.addFeature(f)

                        temp_layer.updateExtents() 
                        QgsProject.instance().removeMapLayers([new_points_temp_layer.id()])
                        
                        
                        if not project_file_path:
                            #add temporary layer to the map
                            QgsProject.instance().addMapLayer(temp_layer)
                            #add style from file
                            temp_layer.loadNamedStyle(os.path.join(os.path.join(cmd_folder, 'qml/Trench_LOE_style_colour_size.qml')))    
                            iface.mapCanvas().refresh()
                            
                            #Message to remember that the layer is only temporary
                            QMessageBox.warning(
                            None,
                            'Evaluation Trench Generator',
                            '''Trench_LOE_temp layer successfully added to the map.<br><center><span style="font-size: 15px;"><strong>Warning!</strong></span></center><br>
                            Be aware that this layer is temporary and will be deleted once you close the project.<br>
                            To preserve your data, make sure to save this layer to disk before closing the project. If not saved, all changes made to this layer will be lost.
                            ''')
                        
                       
                        if project_file_path:
                            #Make temporary file permanent 
                            options = QgsVectorFileWriter.SaveVectorOptions()
                            options.driverName = "ESRI Shapefile"
                            
                            QgsVectorFileWriter.writeAsVectorFormatV2(temp_layer, trench_LOE_path, QgsCoordinateTransformContext(), options)
                            
                            new_file = QgsVectorLayer(trench_LOE_path, tr_LOE_filename, "ogr")
                            
                            QgsProject.instance().addMapLayer(new_file)
                        
                            #add style from file
                            new_file.loadNamedStyle(os.path.join(os.path.join(cmd_folder, 'qml/Trench_LOE_style_colour_size.qml')))    
                            iface.mapCanvas().refresh()
                        
                        
                        
                        if trench_by_number_check == True and trench_by_ares_check == False:
                            QMessageBox.about(
                            None,
                            'Evaluation Trench Generator',
                            '''{} trenches successfully added to the map.'''.format(trench_by_number))
                        
                        if trench_by_number_check == False and trench_by_ares_check == True: 
                            QMessageBox.about(
                            None,
                            'Evaluation Trench Generator',
                            '''{} trenches successfully added to the map. '''.format(round(trench_number_by_area)))

    def rotateTrench_counterclockwise(self):
        layers_list = QgsProject.instance().mapLayers()
        
        if len(layers_list)!= 0:                  
            layer = iface.activeLayer()
            layer.startEditing()
            layer.beginEditCommand("Rotate Selected Trench")

            feat_to_change=[]
            for f in layer.selectedFeatures():
                g = f.geometry()
                centroid = g.centroid().asPoint()
                
                ro = g.rotate(-10, centroid)
                feat_to_change.append(f.id())
                feat_to_change.append(g)
                layer.changeGeometry(feat_to_change[0],feat_to_change[1])
                feat_to_change.clear()
                layer.triggerRepaint()
                iface.mapCanvas().refresh()
                    
            layer.endEditCommand()

        if len(layers_list)== 0:
            return self.dontdonothing()   
 
    def rotateTrench_clockwise(self):
        layers_list = QgsProject.instance().mapLayers()

        if len(layers_list)!= 0:                  
            layer = iface.activeLayer()
            layer.startEditing()
            layer.beginEditCommand("Rotate Selected Trench")

            feat_to_change=[]
            for f in layer.selectedFeatures():
                g = f.geometry()
                centroid = g.centroid().asPoint()
                
                ro = g.rotate(10, centroid)
                feat_to_change.append(f.id())
                feat_to_change.append(g)
                layer.changeGeometry(feat_to_change[0],feat_to_change[1])
                feat_to_change.clear()
                layer.triggerRepaint()
                iface.mapCanvas().refresh()
                    
            layer.endEditCommand()
            
        if len(layers_list)== 0:
            return self.dontdonothing()
   
    def routeNumeration(self):       
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            #self.first_start = False
            self.dlg2 = EvalTrenchRouteNumbersDialog()
            self.layers = {layer.name():layer for layer in QgsProject.instance().mapLayers().values() if layer.type()== 0}
            self.get_route_layer()
            self.get_loe_layer()
            
            
        # show the dialog
        self.dlg2.show()
        # Run the dialog event loop
        result = self.dlg2.exec_()
        # See if OK was pressed
        

        if result:
            trench_first_number = self.dlg2.tr_first_num_spinBox.value()
            route_layer_name = self.dlg2.routelayer_comboBox.currentText()
            if len(route_layer_name) == 0:
                QMessageBox.about(None,'Evaluation Trench Generator', 'No route layer was selected. Please select a layer.')
                return self.dontdonothing()
            else:
                self.shpLayer = self.layers[self.dlg2.routelayer_comboBox.currentText()]
           
                trench_loe_layer_name = self.dlg2.trenchLOE_layer_comboBox.currentText()
                if len(trench_loe_layer_name) == 0:
                    QMessageBox.about(None,'Evaluation Trench Generator', 'No trenches LOE layer was selected. Please select a layer.')
                    return self.dontdonothing()
            
                else: 
                    self.shpLayer = self.layers[self.dlg2.trenchLOE_layer_comboBox.currentText()] 

                route_lay = QgsProject.instance().mapLayersByName(route_layer_name)[0]
                trenchLOE_lay = QgsProject.instance().mapLayersByName(trench_loe_layer_name)[0]
                
                fea_id = []
                for fea in route_lay.getFeatures():                    
                    fea_id.append (fea.id())
                    
                if len(fea_id) == 0: 
                    QMessageBox.about(None,'Evaluation Trench Generator', '''The Route layer doesn't contain any valid line. Please draw on map the route representing the numbering order and retry.''')
                    return self.dontdonothing()
                if len(fea_id) != 0: 
                    
                    route_id = fea_id[0]

                    trenchLOE_lay.startEditing()

                    e = QgsExpression( '''\
                    if( overlay_intersects( layer:='{}') is True,\
                    with_variable('route', geometry( get_feature_by_id('{}', {})),\
                    array_find(\
                    array_filter(\
                    array_sort(\
                    array_agg(line_locate_point(@route, start_point(intersection($geometry, @route))))\
                    ), @element>=0),\
                    line_locate_point(@route, start_point(intersection($geometry, @route)))\
                    ))+{}\
                    ,"loe_no")\
                    '''.format(route_layer_name, route_layer_name, route_id, trench_first_number ) )

                    context = QgsExpressionContext()
                    context.appendScopes(QgsExpressionContextUtils.globalProjectLayerScopes(trenchLOE_lay))

                    for f in trenchLOE_lay.getFeatures():
                        context.setFeature(f)
                        f['loe_no'] = e.evaluate( context )
                        trenchLOE_lay.updateFeature(f)

                    trenchLOE_lay.commitChanges()

    def check_eval_site(self): 
        self.dlg2.trenchLOE_layer_comboBox.setEnabled(True)
        self.dlg2.button_box.setEnabled(True)
        self.dlg2.LOE_label.setEnabled(True)
        self.dlg2.LOE_label.setText('Trench LOE layer')
        
    def check_exc_site(self): 
        self.dlg2.trenchLOE_layer_comboBox.setEnabled(True)
        self.dlg2.button_box.setEnabled(True)
        self.dlg2.LOE_label.setEnabled(True)
        self.dlg2.LOE_label.setText('Excavation LOE layer')

    def generate_stakeout_points(self):
        if self.first_start == True:
            #self.first_start = False
            self.dlg2 = EvalTrenchGenerateStakeOutPointsDialog()
                        
            self.layers = {layer.name():layer for layer in QgsProject.instance().mapLayers().values() if layer.type()== 0}
            self.get_loe_layer()
        
        self.dlg2.trenchLOE_layer_comboBox.setEnabled(False)
        self.dlg2.button_box.setEnabled(False)
        self.dlg2.eval_checkBox.stateChanged.connect(self.check_eval_site)
        self.dlg2.excavation_checkBox.stateChanged.connect(self.check_exc_site)
        self.dlg2.LOE_label.setText('LOE layer')
        self.dlg2.LOE_label.setEnabled(False)
        
        
        # show the dialog
        self.dlg2.show()
        # Run the dialog event loop
        result = self.dlg2.exec_()
        # See if OK was pressed
        if result:
            trench_loe_layer_name = self.dlg2.trenchLOE_layer_comboBox.currentText()

            if len(trench_loe_layer_name) == 0:
                QMessageBox.about(None,'Evaluation Trench Generator', 'No trenches LOE layer was selected. Please select a layer')
                return self.dontdonothing()
        
            else: 
                self.shpLayer = self.layers[self.dlg2.trenchLOE_layer_comboBox.currentText()]  

                    
            # Polygons to lines

            poly_to_line = processing.run("native:polygonstolines", {'INPUT':trench_loe_layer_name,
            'OUTPUT':'TEMPORARY_OUTPUT'}) ["OUTPUT"]

            explode_lines = processing.run("native:explodelines", {'INPUT': poly_to_line,
            'OUTPUT':'TEMPORARY_OUTPUT'})  ["OUTPUT"]

            if self.dlg2.excavation_checkBox.isChecked():
                LOE_points = processing.run("native:pointsalonglines", {'INPUT':explode_lines,
                'DISTANCE':30,'START_OFFSET':0,'END_OFFSET':0,'OUTPUT':'TEMPORARY_OUTPUT'})["OUTPUT"]
            
            if self.dlg2.eval_checkBox.isChecked():
                extract_shortest_sides = processing.run("native:extractbyexpression", {'INPUT':explode_lines,
                'EXPRESSION':'length($geometry) < 3','OUTPUT':'TEMPORARY_OUTPUT'}) ["OUTPUT"]

                LOE_points = processing.run("native:geometrybyexpression", {'INPUT': extract_shortest_sides,
                'OUTPUT_GEOMETRY':2,'WITH_Z':False,'WITH_M':False,
                'EXPRESSION':'collect_geometries(\r\n\r\nline_interpolate_point($geometry, \
                length( $geometry)/2))',
                'OUTPUT':'TEMPORARY_OUTPUT'})  ["OUTPUT"]
            
            
            #Check if the project is saved in the disk 
            # Get the file path of the current project
            project_file_path = QgsProject.instance().fileName()

            if project_file_path:               
                #Check if the folder Shapefile already exist 
                # Create the 'shapefiles' subfolder if it doesn't exist
                shapes_dir = QgsProject.instance().homePath() + '/Shapefiles/'
                if not os.path.exists(shapes_dir):
                    os.mkdir(shapes_dir)
                

                #Check how many stakeout_points files are already present in the folder
                stakeout_points_files_list = []
                os.chdir(shapes_dir)
                for file in glob.glob("StakeOut_Points*.shp"):
                    stakeout_points_files_list.append(file)

                if len(stakeout_points_files_list) == 0:
                    so_point_filename = 'StakeOut_Points.shp'

                if len(stakeout_points_files_list) > 0:
                    so_point_filename = 'StakeOut_Points_{}.shp'.format(len(stakeout_points_files_list))

                if so_point_filename in stakeout_points_files_list:
                    so_point_filename = 'StakeOut_Points_{}.shp'.format((len(stakeout_points_files_list))+1)
                
                trench_LOE_path = shapes_dir+so_point_filename
            
                parameters = {'INPUT': LOE_points, 
                              'OUTPUT': str(shapes_dir+so_point_filename)}
                              
                              
                processing.run("native:multiparttosingleparts", parameters)
        
                so_point_filename_no_ext = so_point_filename.replace('.shp','')
                new_layer = shapes_dir +so_point_filename
                new_stakeout_layer = iface.addVectorLayer(new_layer, so_point_filename_no_ext, "ogr")
                
                #add style from file
                new_stakeout_layer.loadNamedStyle(os.path.join(os.path.join(cmd_folder, 'qml/StakeOut_Points_style.qml')))    
                iface.mapCanvas().refresh()
                
                if not new_stakeout_layer:
                    print("Layer failed to load!")
            
            else:
                #Define a name for the temporary Trench LOE layer
                so_point_filename = 'StakeOut_Points_temp.shp'
                parameters = {'INPUT': LOE_points, 
                              'OUTPUT': 'TEMPORARY_OUTPUT'}

                temp_SO_points = processing.run("native:multiparttosingleparts", parameters)

                so_point_filename_no_ext = so_point_filename.replace('.shp','')
                new_layer = temp_SO_points['OUTPUT']
                if new_layer.isValid():
                    QgsProject.instance().addMapLayer(new_layer)
                    new_layer.setName(so_point_filename_no_ext)
                    
                    #add style from file
                    new_layer.loadNamedStyle(os.path.join(os.path.join(cmd_folder, 'qml/StakeOut_Points_style.qml')))    
                    iface.mapCanvas().refresh()
                            
                    #Message to remember that the layer is only temporary
                    QMessageBox.warning(
                    None,
                    'Evaluation Trench Generator',
                    '''Trench_LOE_temp layer successfully added to the map.<br><center><span style="font-size: 15px;"><strong>Warning!</strong></span></center><br>
                    Be aware that this layer is temporary and will be deleted once you close the project.<br>
                    To preserve your data, make sure to save this layer to disk before closing the project. If not saved, all changes made to this layer will be lost.
                    ''')
                
            
            root = QgsProject.instance().layerTreeRoot()
            new_stakeout_layer_on_map = QgsProject.instance().mapLayersByName(so_point_filename_no_ext)
            thelayer = new_stakeout_layer_on_map[0]
            myblayer = root.findLayer(thelayer.id())
            myClone = myblayer.clone()
            parent = myblayer.parent()
            
            # Check if the group "Mapping" exists in the layer tree
            mapping_group = root.findGroup("Mapping")
            
            if mapping_group is not None:
                mapping_group.insertChildNode(1, myClone)
                parent.removeChildNode(myblayer) 

            #expand group
            layeronplace = QgsProject.instance().mapLayersByName(so_point_filename_no_ext)[0]
            myLayerNode = root.findLayer(layeronplace.id())
            myLayerNode.setExpanded(True)
            
            iface.mapCanvas().refresh()
        
            ## change fields
            field_idx = layeronplace.fields().indexOf('id')
            new_value = 0

            with edit(layeronplace):
                for feat_id in layeronplace.selectedFeatureIds():
                   layeronplace.changeAttributeValue(feat_id, field_idx, new_value)
            

            ### reorganise fields 
            fields_numbers = list(range(len(layeronplace.fields())))

            layeronplace.startEditing()
            res = layeronplace.dataProvider().deleteAttributes(fields_numbers)    # The [0] represents the 1st field, so [1] is the 2nd field etc. To delete multiple fields, use the comma to separate. Eg. [0, 2, 4]
            layeronplace.updateFields()
            
            
            context = QgsExpressionContext()
            context.appendScopes(QgsExpressionContextUtils.globalProjectLayerScopes(layeronplace))

            ###field id
            field_id = QgsField('id', QVariant.Int)
            layeronplace.dataProvider().addAttributes([field_id])
            layeronplace.updateFields()
            idx = layeronplace.fields().indexOf('id')

            e_x = QgsExpression( '0' )
            context = QgsExpressionContext()
            context.appendScopes(QgsExpressionContextUtils.globalProjectLayerScopes(layeronplace))

            for f in layeronplace.getFeatures():
                context.setFeature(f)
                f['id'] = e_x.evaluate( context )
                layeronplace.updateFeature( f )

            ###field X
            field_x = QgsField('X', QVariant.Double)
            layeronplace.dataProvider().addAttributes([field_x])
            layeronplace.updateFields()
            idx = layeronplace.fields().indexOf('X')

            e_x = QgsExpression( "$x" )
            context = QgsExpressionContext()
            context.appendScopes(QgsExpressionContextUtils.globalProjectLayerScopes(layeronplace))

            for f in layeronplace.getFeatures():
                context.setFeature(f)
                f['X'] = e_x.evaluate( context )
                layeronplace.updateFeature( f )

            ###field y
            field_x = QgsField('Y', QVariant.Double)
            layeronplace.dataProvider().addAttributes([field_x])
            layeronplace.updateFields()
            idx = layeronplace.fields().indexOf('Y')

            e_x = QgsExpression( "$y" )
            context = QgsExpressionContext()
            context.appendScopes(QgsExpressionContextUtils.globalProjectLayerScopes(layeronplace))

            for f in layeronplace.getFeatures():
                context.setFeature(f)
                f['Y'] = e_x.evaluate( context )
                layeronplace.updateFeature( f )

            layeronplace.commitChanges()
            
    def generateCSV(self):
        if self.first_start == True:
            #self.first_start = False
            self.dlg7 = EvalTrenchStakeOutRouteCSVDialog()
            self.layers = {layer.name():layer for layer in QgsProject.instance().mapLayers().values() if layer.type()== 0}
            
               
            self.dlg7.stakeout_points_layer_comboBox.setFilters(QgsMapLayerProxyModel.PointLayer)
            self.dlg7.stakeout_survey_path_layer_comboBox.setFilters(QgsMapLayerProxyModel.LineLayer)

        # show the dialog
        self.dlg7.show()
        # Run the dialog event loop
        result = self.dlg7.exec_()
        # See if OK was pressed
        if result:
            SO_point_first_number = self.dlg7.so_point_first_num_spinBox.value()
           
            stakeout_points_layer_name = self.dlg7.stakeout_points_layer_comboBox.currentText()
            if len(stakeout_points_layer_name) == 0:
                QMessageBox.about(None,'Evaluation Trench Generator', 'No Stake-out point layer was selected. Please select a layer')
                return self.dontdonothing()
            else: 
                self.shpLayer = self.layers[self.dlg7.stakeout_points_layer_comboBox.currentText()]  
            
            stakeout_survey_path_layer_name = self.dlg7.stakeout_survey_path_layer_comboBox.currentText()
            if len(stakeout_survey_path_layer_name) == 0:
                QMessageBox.about(None,'Evaluation Trench Generator', 'No Stake-out point layer was selected. Please select a layer')
                return self.dontdonothing()
            else: 
                self.shpLayer = self.layers[self.dlg7.stakeout_survey_path_layer_comboBox.currentText()]
            
            stakeout_points_layer = QgsProject.instance().mapLayersByName(stakeout_points_layer_name)[0]
            stakeout_survey_path_layer = QgsProject.instance().mapLayersByName(stakeout_survey_path_layer_name)[0]
            
            fea_id = []
            for fea in stakeout_survey_path_layer.getFeatures():                    
                fea_id.append (fea.id())
                
            if len(fea_id) == 0: 
                QMessageBox.about(None,'Evaluation Trench Generator', '''The Stake-out path layer doesn't contain any valid line. Please draw on map the suggested survey path representing the numbering order and retry.''')
                return self.dontdonothing()
            if len(fea_id) != 0: 
                
                route_id = fea_id[0]

                stakeout_points_layer.startEditing()
                
                e = QgsExpression( '''\

                with_variable('route', geometry( get_feature_by_id('{0}', {1})),\
                array_find(\
                array_filter(\
                array_sort(\
                array_agg(line_locate_point(@route, start_point(intersection(buffer($geometry,1.5), @route))))\
                ), @element>=0),\
                line_locate_point(@route, start_point(intersection(buffer($geometry,1.5), @route)))\
                ))+{2}
                '''.format(stakeout_survey_path_layer_name, route_id, SO_point_first_number ) )

                context = QgsExpressionContext()
                context.appendScopes(QgsExpressionContextUtils.globalProjectLayerScopes(stakeout_points_layer))

                selectid = []
                for f in stakeout_points_layer.getFeatures():
                    for a in stakeout_survey_path_layer.getFeatures():
                        if f.geometry().buffer(1.5, 5).intersects(a.geometry()):
                            
                            selectid.append(f.id())
                            #same result with .within() and even with a and f switched (the docs aren't that clear on that)
                            
                            break #only one or less intersection are possible

                
                stakeout_points_layer.select(selectid)


                for f in stakeout_points_layer.selectedFeatures():
                    context.setFeature(f)
                    f['id'] = e.evaluate( context )
                    stakeout_points_layer.updateFeature(f)

                stakeout_points_layer.deselect(selectid)
                stakeout_points_layer.commitChanges()


            #Generate CSV for setout
            ####################################
            #points_for_CSV = QgsProject.instance().mapLayersByName('StakeOut_Points')[0]
            points_for_CSV = self.dlg7.stakeout_points_layer_comboBox.currentText()
            if len(points_for_CSV) == 0:
                QMessageBox.about(None,'Evaluation Trench Generator', 'No Stake-out point layer was selected. Please select a layer')
                return self.dontdonothing()
            else: 
                points_for_CSV = self.layers[self.dlg7.stakeout_points_layer_comboBox.currentText()] 
            
            ### add new fields 
            points_for_CSV.startEditing()

            ###recalculate order by ID
            e_order = QgsExpression( '''"id"''' )
            context = QgsExpressionContext()
            context.appendScopes(QgsExpressionContextUtils.globalProjectLayerScopes(points_for_CSV))

            for f in points_for_CSV.getFeatures():
                context.setFeature(f)
                f['id'] = e_order.evaluate( context )
                points_for_CSV.updateFeature( f )

            points_for_CSV.commitChanges()
            points_for_CSV.updateFields()   

            

            ###Generate CSV file
            ##create a new empty table
            uri = 'None?crs=epsg:27700'
            csv = QgsVectorLayer(uri, 'The CSV', 'memory')
            QgsProject.instance().addMapLayer(csv)
            pr = csv.dataProvider()

            # add fields
            pr.addAttributes([QgsField("id", QVariant.Int),
                                QgsField("X",  QVariant.Double),
                                QgsField("Y", QVariant.Double)])
            csv.updateFields() # tell the vector layer to fetch changes from the provider


            #Copy data from stake out points to CSV
            Stakeoutlayer = points_for_CSV.name().replace('.shp','')
            CSV_table_name = 'The CSV'
            
            
            if len(QgsProject.instance().mapLayersByName(Stakeoutlayer)) != 0 and \
            len(QgsProject.instance().mapLayersByName(CSV_table_name)) != 0:
            
                survey_data_layer = QgsProject.instance().mapLayersByName(Stakeoutlayer)[0]
                CSV_table = QgsProject.instance().mapLayersByName(CSV_table_name)[0]
                
                
                if survey_data_layer.isValid() and CSV_table.isValid():
                        if survey_data_layer.type() == QgsMapLayer.VectorLayer and \
                        CSV_table.type() == QgsMapLayer.VectorLayer:
                            
                            iface.setActiveLayer( survey_data_layer ) 
                            survey_data_layer.selectAll()
                            iface.actionCopyFeatures().trigger()
                            iface.setActiveLayer(CSV_table)
                            CSV_table.startEditing()
                            iface.actionPasteFeatures().trigger()
                            CSV_table.commitChanges()
                            survey_data_layer.removeSelection()
                            CSV_table.removeSelection()
                            CSV_table.updateExtents()

            else:
                print ('error')
                pass
                

            ordered_csv = processing.runAndLoadResults("native:orderbyexpression", {'INPUT':CSV_table,
            'EXPRESSION':'"id"',
            'ASCENDING':True,
            'NULLS_FIRST':False,
            'OUTPUT':'TEMPORARY_OUTPUT'}) ["OUTPUT"]

            final_CSV = QgsProject.instance().mapLayersByName('Ordered')[0]

            final_CSV.setName('Setout_CSV')

            QgsProject.instance().removeMapLayers([CSV_table.id()])
            
    def add_empty_LOE_layer(self):
        #Check if the project is saved in the disk 
        # Get the file path of the current project
        project_file_path = QgsProject.instance().fileName()

        if project_file_path:
            #print("The project has been saved to:", project_file_path)
            
            #Check if the folder Shapefile already exist 
            # Create the 'shapefiles' subfolder if it doesn't exist
            shapefile_dir = QgsProject.instance().homePath() + '/Shapefiles/'
            if not os.path.exists(shapefile_dir):
                os.mkdir(shapefile_dir)
                
            #Check how many trench_loe files are already present in the folder
            trench_LOE_files_list = []
            os.chdir(shapefile_dir)
            for file in glob.glob("Trench_LOE*.shp"):
                trench_LOE_files_list.append(file)

            if len(trench_LOE_files_list) == 0:
                tr_LOE_filename = 'Trench_LOE.shp'

            if len(trench_LOE_files_list) > 0:
                tr_LOE_filename = 'Trench_LOE_{}.shp'.format(len(trench_LOE_files_list))

            if tr_LOE_filename in trench_LOE_files_list:
                tr_LOE_filename = 'Trench_LOE_{}.shp'.format((len(trench_LOE_files_list))+1)

            trench_LOE_path = shapefile_dir+tr_LOE_filename
            
        else:
            #print("The project has not been saved yet.")
            #Define a name for the temporary Trench LOE layer
            tr_LOE_filename = 'Trench_LOE_temp.shp'
        
        #create a new temp layer
        temp_layer = QgsVectorLayer("polygon?crs=epsg:27700", tr_LOE_filename, "memory")
        pr = temp_layer.dataProvider()
        pr.addAttributes([QgsField("id",  QVariant.Int),
                          QgsField("loe_no", QVariant.Int),
                          QgsField("surv_type", QVariant.String),
                          QgsField("surv_notes", QVariant.String)])
        temp_layer.updateFields()

        if not project_file_path:
            #add temporary layer to the map
            QgsProject.instance().addMapLayer(temp_layer)
            #add style from file
            temp_layer.loadNamedStyle(os.path.join(os.path.join(cmd_folder, 'qml/Trench_LOE_style_colour_size.qml')))    
            iface.mapCanvas().refresh()
            
            #Message to remember that the layer is only temporary
            QMessageBox.warning(
            None,
            'Evaluation Trench Generator',
            '''Trench_LOE_temp layer successfully added to the map.<br><center><span style="font-size: 15px;"><strong>Warning!</strong></span></center><br>
            Be aware that this layer is temporary and will be deleted once you close the project.<br>
            To preserve your data, make sure to save this layer to disk before closing the project. If not saved, all changes made to this layer will be lost.
            ''')
        
        if project_file_path:
            #Make temporary file permanent 
            options = QgsVectorFileWriter.SaveVectorOptions()
            options.driverName = "ESRI Shapefile"
            
            QgsVectorFileWriter.writeAsVectorFormatV2(temp_layer, trench_LOE_path, QgsCoordinateTransformContext(), options)
            new_file = QgsVectorLayer(trench_LOE_path, tr_LOE_filename, "ogr")
            QgsProject.instance().addMapLayer(new_file)
            #add style from file
            new_file.loadNamedStyle(os.path.join(os.path.join(cmd_folder, 'qml/Trench_LOE_style_colour_size.qml')))    
            iface.mapCanvas().refresh()   
        
    def dontdonothing(self):
        pass
    
    
    